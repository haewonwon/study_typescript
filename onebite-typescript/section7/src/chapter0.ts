// 제네릭
// 일반적인, 포괄적인
// 모든 타입에 두루두루 사용할 수 있는 범용적인 함수

// 아래 함수는 매개변수로 string만 가능
function func<T>(value: T): T {
  return value;
}

// 아래처럼 number, boolean을 받고 싶을 땐 any로 변경하는 게 가장 간단?
let num = func(10);
let bool = func(true);
let str = func('string');
// 위의 변수의 타입들이 각각 number, boolean, string이 아닌 any로 추론됨
// 함수의 반환값 타입은 해당 함수의 리턴값을 기준으로 추론되기 때문
// 다만 어떤 변수가 any 타입으로 추론되는 건 좋지 않음
// num.toUpperCase(); // string에만 쓸 수 있는 메서드를 사용해도 에러가 나지 않음 & 누가 봐도 명확한 number 타입

// any와 비슷한 unknown으로 정의하면 에러는 나지만 toFixed() 같은 메서드도 사용하지 못함
// unknown은 어떤 연산, 메서드도 할 수 없는 전체 집합이기 때문
// 진짜 숫자처럼 사용하려면 타입 좁히기를 이용해야 함
if (typeof num === 'number') {
  num.toFixed();
}
// 다만 이것도 너무 불편함 우리는 인수로 특정 타입을 넣었을 때, 반환값도 그 타입이길 원함
// 이때 사용할 수 있는 게 제네릭 문법임
// 제네릭을 사용하면 함수의 인수에 따라 반환값의 타입을 가변적으로 정할 수 있음

// 어떤 함수를 제네릭 함수로 만드려면 타입 변수라는 걸 선언해 줘야 함
// <T>: 타입 변수
// 자바스크립트의 변수처럼 상황에 따라 다른 타입을 담을 수 있음
// 타입 변수에 어떤 타입이 담기는지 결정되는 시기: 함수를 호출할 때 인수에 따라 결정됨

// 타입 변수에 할당되는 타입을 인수를 통해 추론하도록 하지 않고 개발자가 명시적으로 정의할 수도 있음
let arr = func<[number, number, number]>([1, 2, 3]); // 이때에는 number 배열로 추론될 것

// 다만 튜플 타입으로 추론되게 하고 싶을 때는?
// 1. 타입 단언
// 2. 함수를 호출할 때 함수 이름 뒤에 꺽쇠를 열고 꺽쇠 안에 타입 변수 T에 할당하고 싶은 타입을 적으면 됨 // let arr = func<[number, number, number]>([1, 2, 3]);
